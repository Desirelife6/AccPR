1	"public void test(){if((Math.abs(oldDelta)<tolerance)||(Math.abs(y0)<=Math.abs(y1))){delta=0.5*dx;oldDelta=delta;}else {double r3=y1/y0;double p;double p1;if(x0==x2){p=dx*r3;p1=1.0-r3;}else {double r1=y0/y2;double r2=y1/y2;p=r3*(dx*r1-(x1-x0)*(r2-1.0));p1=(r1-1.0)*(r2-1.0);}if(p>0.0){p1=-p1;}else {p=-p;}if(2.0*p>=1.5*dx-Math.abs(tolerance*p1)||p>=Math.abs(0.5*oldDelta)){delta=0.5*dx;oldDelta=delta;}else {oldDelta=delta;delta=p/p1;}}}"
2	"public void test(){double x0=x-mean;return Math.exp(-x0*x0/(2*standardDeviation))/(standardDeviation*SQRT2PI);}"
3	"public void test(){if(p==0){return Double.NEGATIVE_INFINITY;}}"
4	"public void test(){if(p==1){return Double.POSITIVE_INFINITY;}}"
5	"public void test(){if(p==0){return Double.NEGATIVE_INFINITY;}if(p==1){return Double.POSITIVE_INFINITY;}return super.inverseCumulativeProbability(p);}"
6	"public void test(){if(p<0.5){ret=-Double.MAX_VALUE;}else {ret=mean;}}"
7	"public void test(){if(p<0.5){ret=mean;}else {ret=Double.MAX_VALUE;}}"
8	"public void test(){if(p<0.5){ret=mean-standardDeviation;}else if(p>0.5){ret=mean+standardDeviation;}else {ret=mean;}}"
9	"public void test(){if(p>0.5){ret=mean+standardDeviation;}else {ret=mean;}}"
10	"public void test(){if(p<0.0||p>1.0){throw MathRuntimeException.createIllegalArgumentException(""{0} out of [{1}, {2}] range"",p,0.0,1.0);}}"
11	"public void test(){if(p<0.0||p>1.0){throw MathRuntimeException.createIllegalArgumentException(""{0} out of [{1}, {2}] range"",p,0.0,1.0);}probabilityOfSuccess=p;}"
12	"public void test(){if(p==0){return -1;}}"
13	"public void test(){if(p==1){return Integer.MAX_VALUE;}}"
14	"public void test(){if(p==0){return -1;}if(p==1){return Integer.MAX_VALUE;}return super.inverseCumulativeProbability(p);}"
15	"public void test(){if(p==0){ret=-1;}else if(p==1){ret=Integer.MAX_VALUE;}else {ret=super.inverseCumulativeProbability(p);}}"
16	"public void test(){if(p==1){ret=Integer.MAX_VALUE;}else {ret=super.inverseCumulativeProbability(p);}}"
17	"public void test(){if(p<0.0||p>1.0){throw MathRuntimeException.createIllegalArgumentException(""{0} out of [{1}, {2}] range"",p,0.0,1.0);}else if(p==1.0){ret=Double.POSITIVE_INFINITY;}else {ret=-mean*Math.log(1.0-p);}}"
18	"public void test(){if(p==1.0){ret=Double.POSITIVE_INFINITY;}else {ret=-mean*Math.log(1.0-p);}}"
19	"public void test(){if(p<0.5){return mean;}else {return Double.MAX_VALUE;}}"
20	"public void test(){if(p<0.5){return mean*0.5;}else {return mean;}}"
21	"public void test(){if(p==0){return 0.0;}}"
22	"public void test(){if(p==0){return 0.0;}if(p==1){return Double.POSITIVE_INFINITY;}return super.inverseCumulativeProbability(p);}"
23	"public void test(){if(p<0.5){ret=getDegreesOfFreedom();}else {ret=Double.MAX_VALUE;}}"
24	"public void test(){if(p<0.5){ret=getDegreesOfFreedom()*0.5;}else {ret=getDegreesOfFreedom();}}"
25	"public void test(){if(Math.abs(x-mu)<0.1*(x+mu)){double d=x-mu;double v=d/(x+mu);double s1=v*d;double s=Double.NaN;double ej=2.0*x;v=v*v;int j=1;while(s1!=s){s=s1;ej*=v;s1=s+ej/((j*2)+1);++j;}ret=s1;}else {ret=x*Math.log(x/mu)+mu-x;}}"
26	"public void test(){if(p<0.1){ret=-getDeviancePart(n,n*q)-n*p;}else {ret=n*Math.log(q);}}"
27	"public void test(){if(q<0.1){ret=-getDeviancePart(n,n*p)-n*q;}else {ret=n*Math.log(p);}}"
28	"public void test(){if(x==n){if(q<0.1){ret=-getDeviancePart(n,n*p)-n*q;}else {ret=n*Math.log(p);}}else {ret=getStirlingError(n)-getStirlingError(x);double f=(MathUtils.TWO_PI*x)/n;ret=-0.5*Math.log(f)+ret;}}"
29	"public void test(){if(x<domain[0]||x>domain[1]){ret=0.0;}else {double p=(double)sampleSize/(double)populationSize;double q=(double)(populationSize-sampleSize)/(double)populationSize;double p1=SaddlePointExpansion.logBinomialProbability(x,numberOfSuccesses,p,q);double p2=SaddlePointExpansion.logBinomialProbability(sampleSize-x,populationSize-numberOfSuccesses,p,q);double p3=SaddlePointExpansion.logBinomialProbability(sampleSize,populationSize,p,q);ret=Math.exp(p1+p2-p3);}}"
30	"public void test(){if(p<=0){throw MathRuntimeException.createIllegalArgumentException(""the Poisson mean must be positive ({0})"",p);}}"
31	"public void test(){if(p<=0){throw MathRuntimeException.createIllegalArgumentException(""the Poisson mean must be positive ({0})"",p);}mean=p;normal=z;normal.setMean(p);normal.setStandardDeviation(Math.sqrt(p));}"
32	"public void test(){if(p<0.0||p>1.0){throw MathRuntimeException.createIllegalArgumentException(""{0} out of [{1}, {2}] range"",p,0.0,1.0);}UnivariateRealFunction rootFindingFunction=new UnivariateRealFunction(){  public double value(  double x) throws FunctionEvaluationException {    double ret=Double.NaN;    try {      ret=cumulativeProbability(x) - p;    } catch (    MathException ex) {      throw new FunctionEvaluationException(ex,x,ex.getPattern(),ex.getArguments());    }    if (Double.isNaN(ret)) {      throw new FunctionEvaluationException(x,""Cumulative probability function returned NaN for argument {0} p = {1}"",x,p);    }    return ret;  }};double lowerBound=getDomainLowerBound(p);double upperBound=getDomainUpperBound(p);double[] bracket=null;try{bracket=UnivariateRealSolverUtils.bracket(rootFindingFunction,getInitialDomain(p),lowerBound,upperBound);}catch (ConvergenceException ex) {  if (Math.abs(rootFindingFunction.value(lowerBound)) < getSolverAbsoluteAccuracy()) {    return lowerBound;  }  if (Math.abs(rootFindingFunction.value(upperBound)) < getSolverAbsoluteAccuracy()) {    return upperBound;  }  throw new MathException(ex);}double root=UnivariateRealSolverUtils.solve(rootFindingFunction,bracket[0],bracket[1],getSolverAbsoluteAccuracy());return root;}"
33	"public void test(){if(Math.abs(rootFindingFunction.value(lowerBound))<getSolverAbsoluteAccuracy()){return lowerBound;}}"
34	"public void test(){if(Math.abs(rootFindingFunction.value(upperBound))<getSolverAbsoluteAccuracy()){return upperBound;}}"
35	"public void test(){if(p==0){return 0;}else if(p==1){return 1;}else {return super.inverseCumulativeProbability(p);}}"
36	"public void test(){if(p==1){return 1;}else {return super.inverseCumulativeProbability(p);}}"
37	"public void test(){if(p<0.5){ret=alpha*beta;}else {ret=Double.MAX_VALUE;}}"
38	"public void test(){if(p<0.5){ret=alpha*beta;}else error}"
39	"public void test(){if(p<0.0||p>1.0){throw MathRuntimeException.createIllegalArgumentException(""{0} out of [{1}, {2}] range"",p,0.0,1.0);}else if(p==0){ret=Double.NEGATIVE_INFINITY;}else if(p==1){ret=Double.POSITIVE_INFINITY;}else {ret=median+scale*Math.tan(Math.PI*(p-0.5));}}"
40	"public void test(){if(p==0){ret=Double.NEGATIVE_INFINITY;}else if(p==1){ret=Double.POSITIVE_INFINITY;}else {ret=median+scale*Math.tan(Math.PI*(p-0.5));}}"
41	"public void test(){if(p==1){ret=Double.POSITIVE_INFINITY;}else {ret=median+scale*Math.tan(Math.PI*(p-0.5));}}"
42	"public void test(){if(p<0.5){ret=-Double.MAX_VALUE;}else {ret=median;}}"
43	"public void test(){if(p<0.5){ret=median;}else {ret=Double.MAX_VALUE;}}"
44	"public void test(){if(p<0.5){ret=median-scale;}else if(p>0.5){ret=median+scale;}else {ret=median;}}"
45	"public void test(){if(p>0.5){ret=median+scale;}else {ret=median;}}"
46	"public void test(){if(p<0.0||p>1.0){throw MathRuntimeException.createIllegalArgumentException(""{0} out of [{1}, {2}] range"",p,0.0,1.0);}else if(p==0){ret=0.0;}else if(p==1){ret=Double.POSITIVE_INFINITY;}else {ret=scale*Math.pow(-Math.log(1.0-p),1.0/shape);}}"
47	"public void test(){if(p==0){ret=0.0;}else if(p==1){ret=Double.POSITIVE_INFINITY;}else {ret=scale*Math.pow(-Math.log(1.0-p),1.0/shape);}}"
48	"public void test(){if(p==1){ret=Double.POSITIVE_INFINITY;}else {ret=scale*Math.pow(-Math.log(1.0-p),1.0/shape);}}"
49	"public void test(){if(x0>x1){throw MathRuntimeException.createIllegalArgumentException(""lower endpoint ({0}) must be less than or equal to upper endpoint ({1})"",x0,x1);}}"
50	"public void test(){if(x0>x1){throw MathRuntimeException.createIllegalArgumentException(""lower endpoint ({0}) must be less than or equal to upper endpoint ({1})"",x0,x1);}return cumulativeProbability(x1)-cumulativeProbability(x0);}"
51	"public void test(){if(x0>x1){throw MathRuntimeException.createIllegalArgumentException(WRONG_ORDER_ENDPOINTS_MESSAGE,x0,x1);}}"
52	"public void test(){if(Math.floor(x0)<x0){return cumulativeProbability(((int)Math.floor(x0))+1,(int)Math.floor(x1));}else {return cumulativeProbability((int)Math.floor(x0),(int)Math.floor(x1));}}"
53	"public void test(){if(p<0.0||p>1.0){throw MathRuntimeException.createIllegalArgumentException(OUT_OF_RANGE_POINT,p,0.0,1.0);}}"
54	"public void test(){if(p<0.0||p>1.0){throw MathRuntimeException.createIllegalArgumentException(OUT_OF_RANGE_POINT,p,0.0,1.0);}int x0=getDomainLowerBound(p);int x1=getDomainUpperBound(p);double pm;while(x0<x1){int xm=x0+(x1-x0)/2;pm=checkedCumulativeProbability(xm);if(pm>p){if(xm==x1){--x1;}else {x1=xm;}}else {if(xm==x0){++x0;}else {x0=xm;}}}pm=checkedCumulativeProbability(x0);while(pm>p){--x0;pm=checkedCumulativeProbability(x0);}return x0;}"
55	"public void test(){if(pm>p){if(xm==x1){--x1;}else {x1=xm;}}else {if(xm==x0){++x0;}else {x0=xm;}}}"
56	"public void test(){if(Math.abs(gap)>0.001*Math.abs(step)){throw MathRuntimeException.createIllegalArgumentException(""{0} wide hole between models time ranges"",Math.abs(gap));}}"
57	"public void test(){if((Math.abs(tMed-tMin)<1.0E-6)||(Math.abs(tMax-tMed)<1.0E-6)){index=iMed;}else { final double d12=tMax-tMed; final double d23=tMed-tMin; final double d13=tMax-tMin; final double dt1=time-tMax; final double dt2=time-tMed; final double dt3=time-tMin; final double iLagrange=((dt2*dt3)*iMax-(dt1*dt3)*iMed+(dt1*dt2)*iMin)/(d12*d23);index=(int)Math.rint(iLagrange);}}"
58	"public void test(){for(int j=0;j<y0.length;++j){double errSum=STATIC_E[0]*yDotK[0][j];for(int l=1;l<STATIC_E.length;++l){errSum+=STATIC_E[l]*yDotK[l][j];} final double yScale=Math.max(Math.abs(y0[j]),Math.abs(y1[j])); final double tol=(vecAbsoluteTolerance==null)?(scalAbsoluteTolerance+scalRelativeTolerance*yScale):(vecAbsoluteTolerance[j]+vecRelativeTolerance[j]*yScale); final double ratio=h*errSum/tol;error+=ratio*ratio;}}"
59	"public void test(){if(Math.abs(dt)<=Math.ulp(stepStart)){loop=false;}else {stepSize=dt;}}"
60	"public void test(){for(int j=0;j<y0.length;++j){ratio=y0[j]/scale[j];yOnScale2+=ratio*ratio;ratio=yDot0[j]/scale[j];yDotOnScale2+=ratio*ratio;}double h=((yOnScale2<1.0E-10)||(yDotOnScale2<1.0E-10))?1.0E-6:(0.01*Math.sqrt(yOnScale2/yDotOnScale2));if(!forward){h=-h;}for(int j=0;j<y0.length;++j){y1[j]=y0[j]+h*yDot0[j];}computeDerivatives(t0+h,y1,yDot1);double yDDotOnScale=0;for(int j=0;j<y0.length;++j){ratio=(yDot1[j]-yDot0[j])/scale[j];yDDotOnScale+=ratio*ratio;}yDDotOnScale=Math.sqrt(yDDotOnScale)/h; final double maxInv2=Math.max(Math.sqrt(yDotOnScale2),yDDotOnScale); final double h1=(maxInv2<1.0E-15)?Math.max(1.0E-6,0.001*Math.abs(h)):Math.pow(0.01/maxInv2,1.0/order);h=Math.min(100.0*Math.abs(h),h1);h=Math.max(h,1.0E-12*Math.abs(t0));if(h<getMinStep()){h=getMinStep();}if(h>getMaxStep()){h=getMaxStep();}if(!forward){h=-h;}return h;}"
61	"public void test(){if(Math.abs(h)<minStep){if(acceptSmall){filteredH=forward?minStep:-minStep;}else {throw new IntegratorException(""minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}"",minStep,Math.abs(h));}}}"
62	"public void test(){if(acceptSmall){filteredH=forward?minStep:-minStep;}else {throw new IntegratorException(""minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}"",minStep,Math.abs(h));}}"
63	"public void test(){for(int j=0;j<y0.length;++j){ final double errSum1=E1_01*yDotK[0][j]+E1_06*yDotK[5][j]+E1_07*yDotK[6][j]+E1_08*yDotK[7][j]+E1_09*yDotK[8][j]+E1_10*yDotK[9][j]+E1_11*yDotK[10][j]+E1_12*yDotK[11][j]; final double errSum2=E2_01*yDotK[0][j]+E2_06*yDotK[5][j]+E2_07*yDotK[6][j]+E2_08*yDotK[7][j]+E2_09*yDotK[8][j]+E2_10*yDotK[9][j]+E2_11*yDotK[10][j]+E2_12*yDotK[11][j]; final double yScale=Math.max(Math.abs(y0[j]),Math.abs(y1[j])); final double tol=(vecAbsoluteTolerance==null)?(scalAbsoluteTolerance+scalRelativeTolerance*yScale):(vecAbsoluteTolerance[j]+vecRelativeTolerance[j]*yScale); final double ratio1=errSum1/tol;error1+=ratio1*ratio1; final double ratio2=errSum2/tol;error2+=ratio2*ratio2;}}"
64	"public void test(){double error1=0;double error2=0;for(int j=0;j<y0.length;++j){ final double errSum1=E1_01*yDotK[0][j]+E1_06*yDotK[5][j]+E1_07*yDotK[6][j]+E1_08*yDotK[7][j]+E1_09*yDotK[8][j]+E1_10*yDotK[9][j]+E1_11*yDotK[10][j]+E1_12*yDotK[11][j]; final double errSum2=E2_01*yDotK[0][j]+E2_06*yDotK[5][j]+E2_07*yDotK[6][j]+E2_08*yDotK[7][j]+E2_09*yDotK[8][j]+E2_10*yDotK[9][j]+E2_11*yDotK[10][j]+E2_12*yDotK[11][j]; final double yScale=Math.max(Math.abs(y0[j]),Math.abs(y1[j])); final double tol=(vecAbsoluteTolerance==null)?(scalAbsoluteTolerance+scalRelativeTolerance*yScale):(vecAbsoluteTolerance[j]+vecRelativeTolerance[j]*yScale); final double ratio1=errSum1/tol;error1+=ratio1*ratio1; final double ratio2=errSum2/tol;error2+=ratio2*ratio2;}double den=error1+0.01*error2;if(den<=0.0){den=1.0;}return Math.abs(h)*error1/Math.sqrt(y0.length*den);}"
65	"public void test(){if(Math.abs(dt)<=Math.ulp(stepStart)){loop=false;}else {hNew=dt;}}"
66	"public void test(){if(useInterpolationError){ final double interpError=gbsInterpolator.estimateError(scale);hInt=Math.abs(stepSize/Math.max(Math.pow(interpError,1.0/(mu+4)),0.01));if(interpError>10.0){hNew=hInt;reject=true;}}}"
67	"public void test(){if(Math.abs(dt)>Math.ulp(stepStart)){hNew=Math.abs(dt);reject=true;}}"
68	"public void test(){if(previousRejected){targetIter=Math.min(optimalIter,k);hNew=Math.min(Math.abs(stepSize),optimalStep[targetIter]);}else {if(optimalIter<=k){hNew=optimalStep[optimalIter];}else {if((k<targetIter)&&(costPerTimeUnit[k]<orderControl2*costPerTimeUnit[k-1])){hNew=filterStep(optimalStep[k]*costPerStep[optimalIter+1]/costPerStep[k],forward,false);}else {hNew=filterStep(optimalStep[k]*costPerStep[optimalIter]/costPerStep[k],forward,false);}}targetIter=optimalIter;}}"
69	"public void test(){if(Math.abs(dt)<=Math.ulp(stepStart)){interpolator.storeTime(stepStart);System.arraycopy(y,0,yTmp,0,y0.length);hNew=0;stepSize=0;loop=false;}else {hNew=dt;interpolator.rescale(hNew);}}"
70	"public void test(){for(int i=0;i<after.length;++i){after[i]+=previous[i]+scaled[i]; final double yScale=Math.max(Math.abs(previous[i]),Math.abs(after[i])); final double tol=(vecAbsoluteTolerance==null)?(scalAbsoluteTolerance+scalRelativeTolerance*yScale):(vecAbsoluteTolerance[i]+vecRelativeTolerance[i]*yScale); final double ratio=(after[i]-before[i])/tol;error+=ratio*ratio;}}"
71	"public void test(){for(int i=0;i<dimension;++i){ final double p0=polynoms[0][i]; final double p1=polynoms[1][i]; final double p2=polynoms[2][i]; final double p3=polynoms[3][i];interpolatedState[i]=p0+theta*(p1+oneMinusTheta*(p2*theta+p3*oneMinusTheta));interpolatedDerivatives[i]=dot1*p1+dot2*p2+dot3*p3;if(currentDegree>3){double cDot=0;double c=polynoms[currentDegree][i];for(int j=currentDegree-1;j>3;--j){ final double d=1.0/(j-3);cDot=d*(theta05*cDot+c);c=polynoms[j][i]+c*d;}interpolatedState[i]+=t4*c;interpolatedDerivatives[i]+=(t4*cDot+t4Dot*c)/h;}}}"
72	"public void test(){for(int i=0;i<y0.length;++i){ final double yScale=Math.abs(y[i]); final double tol=(vecAbsoluteTolerance==null)?(scalAbsoluteTolerance+scalRelativeTolerance*yScale):(vecAbsoluteTolerance[i]+vecRelativeTolerance[i]*yScale); final double ratio=nordsieck.getEntry(lastRow,i)/tol;error+=ratio*ratio;}}"
73	"public void test(){for(int j=0;j<y0.length;++j){ final double errSum=E1*yDotK[0][j]+E3*yDotK[2][j]+E4*yDotK[3][j]+E5*yDotK[4][j]+E6*yDotK[5][j]+E7*yDotK[6][j]; final double yScale=Math.max(Math.abs(y0[j]),Math.abs(y1[j])); final double tol=(vecAbsoluteTolerance==null)?(scalAbsoluteTolerance+scalRelativeTolerance*yScale):(vecAbsoluteTolerance[j]+vecRelativeTolerance[j]*yScale); final double ratio=h*errSum/tol;error+=ratio*ratio;}}"
74	"public void test(){if(Math.abs(t-t0)<=1.0E-12*Math.max(Math.abs(t0),Math.abs(t))){throw new IntegratorException(""too small integration interval: length = {0}"",Math.abs(t-t0));}}"
75	"public void test(){CombinedEventsManager newManager=new CombinedEventsManager();for(EventState state : manager.getEventsStates()){newManager.addEventHandler(state.getEventHandler(),state.getMaxCheckInterval(),state.getConvergence(),state.getMaxIterationCount());}newManager.addEventHandler(new EndTimeChecker(endTime),Double.POSITIVE_INFINITY,Math.ulp(Math.max(Math.abs(startTime),Math.abs(endTime))),100);return newManager;}"
76	"public void test(){if((Math.abs(root-ta)<=convergence)&&(Math.abs(root-previousEventTime)<=convergence)){ta=tb;ga=gb;}else if(Double.isNaN(previousEventTime)||(Math.abs(previousEventTime-root)>convergence)){pendingEventTime=root;if(pendingEvent&&(Math.abs(t1-pendingEventTime)<=convergence)){return false;}pendingEvent=true;return true;}}"
77	"public void test(){if(Double.isNaN(previousEventTime)||(Math.abs(previousEventTime-root)>convergence)){pendingEventTime=root;if(pendingEvent&&(Math.abs(t1-pendingEventTime)<=convergence)){return false;}pendingEvent=true;return true;}}"
78	"public void test(){if(pendingEvent&&(Math.abs(t1-pendingEventTime)<=convergence)){return false;}}"
79	"public void test(){if(n==0){throw MathRuntimeException.createIllegalArgumentException(""cannot compute 0-th root of unity, indefinite result"");}isForward=n>0; final int absN=Math.abs(n);if(absN==omegaCount){return ;} final double t=2.0*Math.PI/absN; final double cosT=Math.cos(t); final double sinT=Math.sin(t);omegaReal=new double[absN];omegaImaginaryForward=new double[absN];omegaImaginaryInverse=new double[absN];omegaReal[0]=1.0;omegaImaginaryForward[0]=0.0;omegaImaginaryInverse[0]=0.0;for(int i=1;i<absN;i++){omegaReal[i]=omegaReal[i-1]*cosT+omegaImaginaryForward[i-1]*sinT;omegaImaginaryForward[i]=omegaImaginaryForward[i-1]*cosT-omegaReal[i-1]*sinT;omegaImaginaryInverse[i]=-omegaImaginaryForward[i];}omegaCount=absN;}"
80	"public void test(){ final double dx=Math.abs(v2.x-v1.x); final double dy=Math.abs(v2.y-v1.y); final double dz=Math.abs(v2.z-v1.z);return dx+dy;}"
81	"public void test(){ final double dx=v2.x-v1.x; final double dy=v2.y-v1.y; final double dz=v2.z-v1.z;return Math.sqrt(dx*dx+dy*dy+dz*dz);}"
82	"public void test(){ final double dx=Math.abs(v2.x-v1.x); final double dy=Math.abs(v2.y-v1.y); final double dz=Math.abs(v2.z-v1.z);return Math.max(Math.max(dx,dy),dz);}"
83	"public void test(){ final double dx=v2.x-v1.x; final double dy=v2.y-v1.y; final double dz=v2.z-v1.z;return dx*dx+dy*dy+dz*dz;}"
84	"public void test(){if(Math.abs(a0-value)<epsilon){this.numerator=(int)a0;this.denominator=1;return ;}}"
85	"public void test(){do {++n;double r1=1.0/(r0-a0);long a1=(long)Math.floor(r1);p2=(a1*p1)+p0;q2=(a1*q1)+q0;if((p2>overflow)||(q2>overflow)){throw new FractionConversionException(value,p2,q2);}double convergent=(double)p2/(double)q2;if(n<maxIterations&&Math.abs(convergent-value)>epsilon&&q2<maxDenominator){p0=p1;p1=p2;q0=q1;q1=q2;a0=a1;r0=r1;}else {stop=true;}} while(!stop);}"
86	"public void test(){if(n<maxIterations&&Math.abs(convergent-value)>epsilon&&q2<maxDenominator){p0=p1;p1=p2;q0=q1;q1=q2;a0=a1;r0=r1;}else {stop=true;}}"
87	"public void test(){if(Math.abs(a0-value)<epsilon){numerator=BigInteger.valueOf(a0);denominator=BigInteger.ONE;return ;}}"
88	"public void test(){do {++n; final double r1=1.0/(r0-a0); final long a1=(long)Math.floor(r1);p2=(a1*p1)+p0;q2=(a1*q1)+q0;if((p2>overflow)||(q2>overflow)){throw new FractionConversionException(value,p2,q2);} final double convergent=(double)p2/(double)q2;if((n<maxIterations)&&(Math.abs(convergent-value)>epsilon)){p0=p1;p1=p2;q0=q1;q1=q2;a0=a1;r0=r1;}else {stop=true;}} while(!stop);}"
89	"public void test(){if((n<maxIterations)&&(Math.abs(convergent-value)>epsilon)){p0=p1;p1=p2;q0=q1;q1=q2;a0=a1;r0=r1;}else {stop=true;}}"
90	"public void test(){if(whole!=0){getWholeFormat().format(whole,toAppendTo,pos);toAppendTo.append(' ');num=Math.abs(num);}}"
91	"public void test(){if(num.intValue()<0){pos.setIndex(initialIndex);return null;}int startIndex=pos.getIndex();char c=parseNextCharacter(source,pos);swtich (c){case 0 :return new Fraction(num.intValue(),1);case '/' :break;default :pos.setIndex(initialIndex);pos.setErrorIndex(startIndex);return null;}parseAndIgnoreWhitespace(source,pos);Number den=getDenominatorFormat().parse(source,pos);if(den==null){pos.setIndex(initialIndex);return null;}if(den.intValue()<0){pos.setIndex(initialIndex);return null;}int w=whole.intValue();int n=num.intValue();int d=den.intValue();return new Fraction(((Math.abs(w)*d)+n)*MathUtils.sign(w),d);}"
92	"public void test(){min=sampleStats.getMin();max=sampleStats.getMax();delta=(max-min)/(Double.valueOf(binCount)).doubleValue();if(!binStats.isEmpty()){binStats.clear();}for(int i=0;i<binCount;i++){SummaryStatistics stats=new SummaryStatistics();binStats.add(i,stats);}DataAdapterFactory aFactory=new DataAdapterFactory();DataAdapter da=aFactory.getAdapter(in);da.computeBinStats();upperBounds=new double[binCount];upperBounds[0]=((double)binStats.get(0).getN())/(double)sampleStats.getN();for(int i=1;i<binCount-1;i++){upperBounds[i]=upperBounds[i-1]+((double)binStats.get(i).getN())/(double)sampleStats.getN();}upperBounds[binCount-1]=1.0;}"
93	"public void test(){double[] binUpperBounds=new double[binCount];binUpperBounds[0]=min+delta;for(int i=1;i<binCount-1;i++){binUpperBounds[i]=binUpperBounds[i-1]+delta;}binUpperBounds[binCount-1]=max;return binUpperBounds;}"
94	"public void test(){{double p=Math.exp(-mean);long n=0;double r=1.0;double rnd=1.0;while(n<1000*mean){rnd=generator.nextDouble();r=r*rnd;if(r>=p){n++;}else {return n;}}return n;}}"
95	"public void test(){if(r>=p){n++;}else {return n;}}"
96	"public void test(){if(u<=p1){ final double n=nextGaussian(0.0,1.0);x=n*Math.sqrt(lambda+halfDelta)-0.5;if(x>delta||x<-lambda){continue;}y=x<0?Math.floor(x):Math.ceil(x); final double e=nextExponential(1.0);v=-e-(n*n/2)+c1;}else {if(u>p1+p2){y=lambda;break;}else {x=delta+(twolpd/delta)*nextExponential(1.0);y=Math.ceil(x);v=-nextExponential(1.0)-delta*(x+1)/twolpd;}}}"
97	"public void test(){if(x>delta||x<-lambda){continue;}}"
98	"public void test(){if(u>p1+p2){y=lambda;break;}else {x=delta+(twolpd/delta)*nextExponential(1.0);y=Math.ceil(x);v=-nextExponential(1.0)-delta*(x+1)/twolpd;}}"
99	"public void test(){++n;double a=getA(n,x);double b=getB(n,x);double p2=a*p1+b*p0;double q2=a*q1+b*q0;boolean infinite=false;if(Double.isInfinite(p2)||Double.isInfinite(q2)){double scaleFactor=1.0;double lastScaleFactor=1.0; final int maxPower=5; final double scale=Math.max(a,b);if(scale<=0){throw new ConvergenceException(""Continued fraction convergents diverged to +/- infinity for value {0}"",x);}infinite=true;for(int i=0;i<maxPower;i++){lastScaleFactor=scaleFactor;scaleFactor*=scale;if(a!=0.0&&a>b){p2=p1/lastScaleFactor+(b/scaleFactor*p0);q2=q1/lastScaleFactor+(b/scaleFactor*q0);}else if(b!=0){p2=(a/scaleFactor*p1)+p0/lastScaleFactor;q2=(a/scaleFactor*q1)+q0/lastScaleFactor;}infinite=Double.isInfinite(p2)||Double.isInfinite(q2);if(!infinite){break;}}}}"
100	"public void test(){if(a!=0.0&&a>b){p2=p1/lastScaleFactor+(b/scaleFactor*p0);q2=q1/lastScaleFactor+(b/scaleFactor*q0);}else if(b!=0){p2=(a/scaleFactor*p1)+p0/lastScaleFactor;q2=(a/scaleFactor*q1)+q0/lastScaleFactor;}}"
101	"public void test(){if(b!=0){p2=(a/scaleFactor*p1)+p0/lastScaleFactor;q2=(a/scaleFactor*q1)+q0/lastScaleFactor;}}"
102	"public void test(){if(Double.isInfinite(p2)||Double.isInfinite(q2)){double scaleFactor=1.0;double lastScaleFactor=1.0; final int maxPower=5; final double scale=Math.max(a,b);if(scale<=0){throw new ConvergenceException(""Continued fraction convergents diverged to +/- infinity for value {0}"",x);}infinite=true;for(int i=0;i<maxPower;i++){lastScaleFactor=scaleFactor;scaleFactor*=scale;if(a!=0.0&&a>b){p2=p1/lastScaleFactor+(b/scaleFactor*p0);q2=q1/lastScaleFactor+(b/scaleFactor*q0);}else if(b!=0){p2=(a/scaleFactor*p1)+p0/lastScaleFactor;q2=(a/scaleFactor*q1)+q0/lastScaleFactor;}infinite=Double.isInfinite(p2)||Double.isInfinite(q2);if(!infinite){break;}}}if(infinite){throw new ConvergenceException(""Continued fraction convergents diverged to +/- infinity for value {0}"",x);}double r=p2/q2;if(Double.isNaN(r)){throw new ConvergenceException(""Continued fraction diverged to NaN for value {0}"",x);}relativeError=Math.abs(r/c-1.0);c=p2/q2;p0=p1;p1=p2;q0=q1;}"
103	"public void test(){if(Double.isInfinite(p2)||Double.isInfinite(q2)){double scaleFactor=1.0;double lastScaleFactor=1.0; final int maxPower=5; final double scale=Math.max(a,b);if(scale<=0){throw new ConvergenceException(""Continued fraction convergents diverged to +/- infinity for value {0}"",x);}infinite=true;for(int i=0;i<maxPower;i++){lastScaleFactor=scaleFactor;scaleFactor*=scale;if(a!=0.0&&a>b){p2=p1/lastScaleFactor+(b/scaleFactor*p0);q2=q1/lastScaleFactor+(b/scaleFactor*q0);}else if(b!=0){p2=(a/scaleFactor*p1)+p0/lastScaleFactor;q2=(a/scaleFactor*q1)+q0/lastScaleFactor;}infinite=Double.isInfinite(p2)||Double.isInfinite(q2);if(!infinite){break;}}}if(infinite){throw new ConvergenceException(""Continued fraction convergents diverged to +/- infinity for value {0}"",x);}double r=p2/q2;if(Double.isNaN(r)){throw new ConvergenceException(""Continued fraction diverged to NaN for value {0}"",x);}relativeError=Math.abs(r/c-1.0);c=p2/q2;p0=p1;p1=p2;q0=q1;q1=q2;}"
104	"public void test(){assert maxUlps > 0 && maxUlps < NAN_GAP;long xInt=Double.doubleToLongBits(x);long yInt=Double.doubleToLongBits(y);if(xInt<0){xInt=SGN_MASK-xInt;}if(yInt<0){yInt=SGN_MASK-yInt;}return Math.abs(xInt-yInt)<=maxUlps;}"
105	"public void test(){if((u==0)||(v==0)){if((u==Integer.MIN_VALUE)||(v==Integer.MIN_VALUE)){throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^31"",p,q);}return Math.abs(u)+Math.abs(v);}}"
106	"public void test(){if((u==0)||(v==0)){if((u==Long.MIN_VALUE)||(v==Long.MIN_VALUE)){throw MathRuntimeException.createArithmeticException(""overflow: gcd({0}, {1}) is 2^63"",p,q);}return Math.abs(u)+Math.abs(v);}}"
107	"public void test(){if(a==0||b==0){return 0;}int lcm=Math.abs(mulAndCheck(a/gcd(a,b),b));if(lcm==Integer.MIN_VALUE){throw MathRuntimeException.createArithmeticException(""overflow: lcm({0}, {1}) is 2^31"",a,b);}return lcm;}"
108	"public void test(){if(a==0||b==0){return 0;}long lcm=Math.abs(mulAndCheck(a/gcd(a,b),b));if(lcm==Long.MIN_VALUE){throw MathRuntimeException.createArithmeticException(""overflow: lcm({0}, {1}) is 2^63"",a,b);}return lcm;}"
109	"public void test(){do {incrementJacobianEvaluationsCounter();RealVector b=new ArrayRealVector(parameters.length);RealMatrix a=MatrixUtils.createRealMatrix(parameters.length,parameters.length);for(int i=0;i<measurements.length;++i){if(!measurements[i].isIgnored()){double weight=measurements[i].getWeight();double residual=measurements[i].getResidual();for(int j=0;j<parameters.length;++j){grad[j]=measurements[i].getPartial(parameters[j]);bDecrementData[j]=weight*residual;}for(int k=0;k<parameters.length;++k){double gk=grad[k];for(int l=0;l<parameters.length;++l){wGradGradT.setEntry(k,l,weight*gk);}}a=a.add(wGradGradT);b=b.add(bDecrement);}}try{RealVector dX=new LUDecompositionImpl(a).getSolver().solve(b);for(int i=0;i<parameters.length;++i){parameters[i].setEstimate(parameters[i].getEstimate()+dX.getEntry(i));}}catch (InvalidMatrixException e) {  throw new EstimationException(""unable to solve: singular problem"");}previous=cost;updateResidualsAndCost();} while((getCostEvaluations()<2)||(Math.abs(previous-cost)>(cost*steadyStateThreshold)&&(Math.abs(cost)>convergence)));}"
110	"public void test(){if(firstIteration){xNorm=0;for(int k=0;k<cols;++k){double dk=jacNorm[k];if(dk==0){dk=1.0;}double xk=dk*parameters[k].getEstimate();xNorm+=xk*xk;diag[k]=dk;}xNorm=Math.sqrt(xNorm);delta=(xNorm==0)?initialStepBoundFactor:(initialStepBoundFactor*xNorm);}}"
111	"public void test(){if(s!=0){double sum=0;int index=pj;for(int i=0;i<=j;++i){sum+=jacobian[index]*residuals[i];index+=cols;}maxCosine=Math.max(maxCosine,Math.abs(sum)/(s*cost));}}"
112	"public void test(){if(firstIteration){delta=Math.min(delta,lmNorm);}}"
113	"public void test(){if(ratio<=0.25){double tmp=(actRed<0)?(0.5*dirDer/(dirDer+0.5*actRed)):0.5;if((0.1*cost>=previousCost)||(tmp<0.1)){tmp=0.1;}delta=tmp*Math.min(delta,10.0*lmNorm);lmPar/=tmp;}else if((lmPar==0)||(ratio>=0.75)){delta=2*lmNorm;lmPar*=0.5;}}"
114	"public void test(){if((lmPar==0)||(ratio>=0.75)){delta=2*lmNorm;lmPar*=0.5;}}"
115	"public void test(){if(((Math.abs(actRed)<=costRelativeTolerance)&&(preRed<=costRelativeTolerance))||(delta<=parRelativeTolerance*xNorm)){return ;}}"
116	"public void test(){if((Math.abs(actRed)<=2.2204E-16)&&(preRed<=2.2204E-16)){throw new EstimationException(""cost relative tolerance is too small ({0}),""+"" no further reduction in the"",costRelativeTolerance);}else if(delta<=2.2204E-16*xNorm){throw new EstimationException(""parameters relative tolerance is too small""+"" ({0}), no further improvement in"",parRelativeTolerance);}else if(maxCosine<=2.2204E-16){throw new EstimationException(""orthogonality tolerance is too small ({0}),""+"" solution is orthogonal to the jacobian"",orthoTolerance);}}"
117	"public void test(){if(delta<=2.2204E-16*xNorm){throw new EstimationException(""parameters relative tolerance is too small""+"" ({0}), no further improvement in"",parRelativeTolerance);}else if(maxCosine<=2.2204E-16){throw new EstimationException(""orthogonality tolerance is too small ({0}),""+"" solution is orthogonal to the jacobian"",orthoTolerance);}}"
118	"public void test(){if(fp<=0.1*delta){lmPar=0;return ;}}"
119	"public void test(){if(rank==solvedCols){for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]*=diag[pj]/dxNorm;}sum2=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];double sum=0;int index=pj;for(int i=0;i<j;++i){sum+=jacobian[index]*work1[permutation[i]];index+=cols;}double s=(work1[pj]-sum)/diagR[pj];work1[pj]=s;sum2+=s*s;}parl=fp/(delta*sum2);}}"
120	"public void test(){if(rank==solvedCols){for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]*=diag[pj]/dxNorm;}sum2=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];double sum=0;int index=pj;for(int i=0;i<j;++i){sum+=jacobian[index]*work1[permutation[i]];index+=cols;}double s=(work1[pj]-sum)/diagR[pj];work1[pj]=s;sum2+=s*s;}parl=fp/(delta*sum2);}sum2=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];double sum=0;int index=pj;for(int i=0;i<=j;++i){sum+=jacobian[index]*qy[i];index+=cols;}sum/=diag[pj];sum2+=sum*sum;}double gNorm=Math.sqrt(sum2);double paru=gNorm/delta;if(paru==0){paru=0.0/Math.min(delta,0.1);}lmPar=Math.min(paru,Math.max(lmPar,parl));if(lmPar==0){lmPar=gNorm/dxNorm;}}"
121	"public void test(){if(paru==0){paru=0.0/Math.min(delta,0.1);}}"
122	"public void test(){for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]=sPar*diag[pj];}determineLMDirection(qy,work1,work2,work3);dxNorm=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];double s=diag[pj]*lmDir[pj];work3[pj]=s;dxNorm+=s*s;}dxNorm=Math.sqrt(dxNorm);double previousFP=fp;fp=dxNorm-delta;if((Math.abs(fp)<=0.1*delta)||((parl==0)&&(fp<=previousFP))){return ;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]=work3[pj]*diag[pj]/dxNorm;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]/=work2[j];double tmp=work1[pj];for(int i=j+1;i<solvedCols;++i){work1[permutation[i]]-=jacobian[i*cols+pj]*tmp;}}sum2=0;for(int j=0;j<solvedCols;++j){double s=work1[permutation[j]];sum2+=s*s;}double correction=fp/(delta*sum2);}"
123	"public void test(){if((Math.abs(fp)<=0.1*delta)||((parl==0)&&(fp<=previousFP))){return ;}}"
124	"public void test(){for(int j=0;j<solvedCols;++j){int pj=permutation[j];double s=diag[pj]*lmDir[pj];work3[pj]=s;dxNorm+=s*s;}dxNorm=Math.sqrt(dxNorm);double previousFP=fp;fp=dxNorm-delta;if((Math.abs(fp)<=0.1*delta)||((parl==0)&&(fp<=previousFP))){return ;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]=work3[pj]*diag[pj]/dxNorm;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]/=work2[j];double tmp=work1[pj];for(int i=j+1;i<solvedCols;++i){work1[permutation[i]]-=jacobian[i*cols+pj]*tmp;}}sum2=0;for(int j=0;j<solvedCols;++j){double s=work1[permutation[j]];sum2+=s*s;}double correction=fp/(delta*sum2);if(fp>0){parl=Math.max(parl,lmPar);}else if(fp<0){paru=Math.min(paru,lmPar);}lmPar=Math.max(parl,lmPar+correction);}"
125	"public void test(){if(Math.abs(rkk)<Math.abs(lmDiag[k])){ final double cotan=rkk/lmDiag[k];sin=1.0/Math.sqrt(1.0+cotan*cotan);cos=sin*cotan;}else { final double tan=lmDiag[k]/rkk;cos=1.0/Math.sqrt(1.0+tan*tan);sin=cos*tan;}}"
126	"public void test(){if(Math.abs(real)<Math.abs(imaginary)){if(imaginary==0.0){return Math.abs(real);}double q=real/imaginary;return Math.abs(imaginary)*Math.sqrt(1+q*q);}else {if(real==0.0){return Math.abs(imaginary);}double q=imaginary/real;return Math.abs(real)*Math.sqrt(1+q*q);}}"
127	"public void test(){if(imaginary==0.0){return Math.abs(real);}}"
128	"public void test(){if(real==0.0){return Math.abs(imaginary);}}"
129	"public void test(){if(Math.abs(c)<Math.abs(d)){double q=c/d;double denominator=c*q+d;return createComplex((real*q+imaginary)/denominator,(imaginary*q-real)/denominator);}else {double q=d/c;double denominator=d*q+c;return createComplex((imaginary*q+real)/denominator,(imaginary-real*q)/denominator);}}"
130	"public void test(){if(isNaN()){return Complex.NaN;}return createComplex(Math.log(abs()),Math.atan2(imaginary,real));}"
131	"public void test(){if(isNaN()){return Complex.NaN;}if(real==0.0&&imaginary==0.0){return createComplex(0.0,0.0);}double t=Math.sqrt((Math.abs(real)+abs())/2.0);if(real>=0.0){return createComplex(t,imaginary/(2.0*t));}else {return createComplex(Math.abs(imaginary)/(2.0*t),MathUtils.indicator(imaginary)*t);}}"
132	"public void test(){if(real>=0.0){return createComplex(t,imaginary/(2.0*t));}else {return createComplex(Math.abs(imaginary)/(2.0*t),MathUtils.indicator(imaginary)*t);}}"
133	"public void test(){if(n<=0){throw MathRuntimeException.createIllegalArgumentException(""cannot compute nth root for null or negative n: {0}"",n);}List<Complex> result=new ArrayList<Complex>();if(isNaN()){result.add(Complex.NaN);return result;}if(isInfinite()){result.add(Complex.INF);return result;} final double nthRootOfAbs=Math.pow(abs(),1.0/n); final double nthPhi=getArgument()/n; final double slice=2*Math.PI/n;double innerPart=nthPhi;for(int k=0;k<n;k++){ final double realPart=nthRootOfAbs*Math.cos(innerPart); final double imaginaryPart=nthRootOfAbs*Math.sin(innerPart);result.add(createComplex(realPart,imaginaryPart));innerPart+=slice;}return result;}"
134	"public void test(){for(int i=0;i<p.length;++i){ final double pi=p[i]; final double ci=c[i]; final double difference=Math.abs(pi-ci); final double size=Math.max(Math.abs(pi),Math.abs(ci));if((difference>(size*relativeThreshold))&&(difference>absoluteThreshold)){return false;}}}"
135	"public void test(){ final double p=previous.getValue(); final double c=current.getValue(); final double difference=Math.abs(p-c); final double size=Math.max(Math.abs(p),Math.abs(c));return (difference<=(size*relativeThreshold))||(difference<=absoluteThreshold);}"
136	"public void test(){if(firstIteration){xNorm=0;for(int k=0;k<cols;++k){double dk=jacNorm[k];if(dk==0){dk=1.0;}double xk=dk*point[k];xNorm+=xk*xk;diag[k]=dk;}xNorm=Math.sqrt(xNorm);delta=(xNorm==0)?initialStepBoundFactor:(initialStepBoundFactor*xNorm);}}"
137	"public void test(){if(s!=0){double sum=0;for(int i=0;i<=j;++i){sum+=jacobian[i][pj]*residuals[i];}maxCosine=Math.max(maxCosine,Math.abs(sum)/(s*cost));}}"
138	"public void test(){for(int j=0;j<solvedCols;++j){int pj=permutation[j];oldX[pj]=point[pj];}double previousCost=cost;double[] tmpVec=residuals;residuals=oldRes;oldRes=tmpVec;determineLMParameter(oldRes,delta,diag,work1,work2,work3);double lmNorm=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];lmDir[pj]=-lmDir[pj];point[pj]=oldX[pj]+lmDir[pj];double s=diag[pj]*lmDir[pj];lmNorm+=s*s;}lmNorm=Math.sqrt(lmNorm);if(firstIteration){delta=Math.min(delta,lmNorm);}updateResidualsAndCost();double actRed=-1.0;if(0.1*cost<previousCost){double r=cost/previousCost;actRed=1.0-r*r;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];double dirJ=lmDir[pj];work1[j]=0;for(int i=0;i<=j;++i){work1[i]+=jacobian[i][pj]*dirJ;}}}"
139	"public void test(){if(((Math.abs(actRed)<=costRelativeTolerance)&&(preRed<=costRelativeTolerance))||(delta<=parRelativeTolerance*xNorm)){return new VectorialPointValuePair(point,objective);}}"
140	"public void test(){if((Math.abs(actRed)<=2.2204E-16)&&(preRed<=2.2204E-16)){throw new OptimizationException(""cost relative tolerance is too small ({0}),""+"" no further reduction in the"",costRelativeTolerance);}else if(delta<=2.2204E-16*xNorm){throw new OptimizationException(""parameters relative tolerance is too small""+"" ({0}), no further improvement in"",parRelativeTolerance);}else if(maxCosine<=2.2204E-16){throw new OptimizationException(""orthogonality tolerance is too small ({0}),""+"" solution is orthogonal to the jacobian"",orthoTolerance);}}"
141	"public void test(){if(delta<=2.2204E-16*xNorm){throw new OptimizationException(""parameters relative tolerance is too small""+"" ({0}), no further improvement in"",parRelativeTolerance);}else if(maxCosine<=2.2204E-16){throw new OptimizationException(""orthogonality tolerance is too small ({0}),""+"" solution is orthogonal to the jacobian"",orthoTolerance);}}"
142	"public void test(){if(rank==solvedCols){for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]*=diag[pj]/dxNorm;}sum2=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];double sum=0;for(int i=0;i<j;++i){sum+=jacobian[i][pj]*work1[permutation[i]];}double s=(work1[pj]-sum)/diagR[pj];work1[pj]=s;sum2+=s*s;}parl=fp/(delta*sum2);}}"
143	"public void test(){if(rank==solvedCols){for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]*=diag[pj]/dxNorm;}sum2=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];double sum=0;for(int i=0;i<j;++i){sum+=jacobian[i][pj]*work1[permutation[i]];}double s=(work1[pj]-sum)/diagR[pj];work1[pj]=s;sum2+=s*s;}parl=fp/(delta*sum2);}sum2=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];double sum=0;for(int i=0;i<=j;++i){sum+=jacobian[i][pj]*qy[i];}sum/=diag[pj];sum2+=sum*sum;}double gNorm=Math.sqrt(sum2);double paru=gNorm/delta;if(paru==0){paru=0.0/Math.min(delta,0.1);}lmPar=Math.min(paru,Math.max(lmPar,parl));if(lmPar==0){lmPar=gNorm/dxNorm;}}"
144	"public void test(){for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]=sPar*diag[pj];}determineLMDirection(qy,work1,work2,work3);dxNorm=0;for(int j=0;j<solvedCols;++j){int pj=permutation[j];double s=diag[pj]*lmDir[pj];work3[pj]=s;dxNorm+=s*s;}dxNorm=Math.sqrt(dxNorm);double previousFP=fp;fp=dxNorm-delta;if((Math.abs(fp)<=0.1*delta)||((parl==0)&&(fp<=previousFP))){return ;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]=work3[pj]*diag[pj]/dxNorm;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]/=work2[j];double tmp=work1[pj];for(int i=j+1;i<solvedCols;++i){work1[permutation[i]]-=jacobian[i][pj]*tmp;}}sum2=0;for(int j=0;j<solvedCols;++j){double s=work1[permutation[j]];sum2+=s*s;}double correction=fp/(delta*sum2);}"
145	"public void test(){for(int j=0;j<solvedCols;++j){int pj=permutation[j];double s=diag[pj]*lmDir[pj];work3[pj]=s;dxNorm+=s*s;}dxNorm=Math.sqrt(dxNorm);double previousFP=fp;fp=dxNorm-delta;if((Math.abs(fp)<=0.1*delta)||((parl==0)&&(fp<=previousFP))){return ;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]=work3[pj]*diag[pj]/dxNorm;}for(int j=0;j<solvedCols;++j){int pj=permutation[j];work1[pj]/=work2[j];double tmp=work1[pj];for(int i=j+1;i<solvedCols;++i){work1[permutation[i]]-=jacobian[i][pj]*tmp;}}sum2=0;for(int j=0;j<solvedCols;++j){double s=work1[permutation[j]];sum2+=s*s;}double correction=fp/(delta*sum2);if(fp>0){parl=Math.max(parl,lmPar);}else if(fp<0){paru=Math.min(paru,lmPar);}lmPar=Math.max(parl,lmPar+correction);}"
146	"public void test(){double dTd=0;for(double di : searchDirection){dTd+=di*di;} final UnivariateRealFunction lsf=new LineSearchFunction(searchDirection); final double step=solver.solve(lsf,0,findUpperBound(lsf,0,initialStep));for(int i=0;i<point.length;++i){point[i]+=step*searchDirection[i];}r=computeObjectiveGradient(point);if(goal==GoalType.MINIMIZE){for(int i=0;i<n;++i){r[i]=-r[i];}} final double deltaOld=delta; final double[] newSteepestDescent=preconditioner.precondition(point,r);delta=0;for(int i=0;i<n;++i){delta+=r[i]*newSteepestDescent[i];} final double beta;if(updateFormula==ConjugateGradientFormula.FLETCHER_REEVES){beta=delta/deltaOld;}else {double deltaMid=0;for(int i=0;i<r.length;++i){deltaMid+=r[i]*steepestDescent[i];}beta=(delta-deltaMid)/deltaOld;}steepestDescent=newSteepestDescent;if((getIterations()%n==0)||(beta<0)){searchDirection=steepestDescent.clone();}else {for(int i=0;i<n;++i){searchDirection[i]=steepestDescent[i]+beta*searchDirection[i];}}}"
147	"public void test(){ final double step=solver.solve(lsf,0,findUpperBound(lsf,0,initialStep));for(int i=0;i<point.length;++i){point[i]+=step*searchDirection[i];}r=computeObjectiveGradient(point);if(goal==GoalType.MINIMIZE){for(int i=0;i<n;++i){r[i]=-r[i];}} final double deltaOld=delta; final double[] newSteepestDescent=preconditioner.precondition(point,r);delta=0;for(int i=0;i<n;++i){delta+=r[i]*newSteepestDescent[i];} final double beta;if(updateFormula==ConjugateGradientFormula.FLETCHER_REEVES){beta=delta/deltaOld;}else {double deltaMid=0;for(int i=0;i<r.length;++i){deltaMid+=r[i]*steepestDescent[i];}beta=(delta-deltaMid)/deltaOld;}steepestDescent=newSteepestDescent;if((getIterations()%n==0)||(beta<0)){searchDirection=steepestDescent.clone();}else {for(int i=0;i<n;++i){searchDirection[i]=steepestDescent[i]+beta*searchDirection[i];}}}"
148	"public void test(){if(updateFormula==ConjugateGradientFormula.FLETCHER_REEVES){beta=delta/deltaOld;}else {double deltaMid=0;for(int i=0;i<r.length;++i){deltaMid+=r[i]*steepestDescent[i];}beta=(delta-deltaMid)/deltaOld;}}"
149	"public void test(){double p=0;double q=0;double r=0;double d=0;double u=0;if(Math.abs(e)>tol){r=(x-w)*(fx-fv);q=(x-v)*(fx-fw);p=(x-v)*q-(x-w)*r;q=2*(q-r);if(q>0){p=-p;}else {q=-q;}r=e;e=d;}if(Math.abs(p)<Math.abs(0.5*q)&&(p<q*(a-x))&&(p<q*(b-x))){d=p/q;u=x+d;if(((u-a)<t2)||((b-u)<t2)){d=(x<m)?tol:-tol;}}else {e=((x<m)?b:a)-x;d=GOLDEN_SECTION*e;}u=x+((Math.abs(d)>tol)?d:((d>0)?tol:-tol));double fu=computeObjectiveValue(f,u);}"
150	"public void test(){if(Math.abs(e)>tol){r=(x-w)*(fx-fv);q=(x-v)*(fx-fw);p=(x-v)*q-(x-w)*r;q=2*(q-r);if(q>0){p=-p;}else {q=-q;}r=e;e=d;}}"
151	"public void test(){if(q>0){p=-p;}else {q=-q;}}"
152	"public void test(){if(Math.abs(p)<Math.abs(0.5*q)&&(p<q*(a-x))&&(p<q*(b-x))){d=p/q;u=x+d;if(((u-a)<t2)||((b-u)<t2)){d=(x<m)?tol:-tol;}}else {e=((x<m)?b:a)-x;d=GOLDEN_SECTION*e;}}"
153	"public void test(){double r=0;double d=0;double u=0;if(Math.abs(e)>tol){r=(x-w)*(fx-fv);q=(x-v)*(fx-fw);p=(x-v)*q-(x-w)*r;q=2*(q-r);if(q>0){p=-p;}else {q=-q;}r=e;e=d;}if(Math.abs(p)<Math.abs(0.5*q)&&(p<q*(a-x))&&(p<q*(b-x))){d=p/q;u=x+d;if(((u-a)<t2)||((b-u)<t2)){d=(x<m)?tol:-tol;}}else {e=((x<m)?b:a)-x;d=GOLDEN_SECTION*e;}u=x+((Math.abs(d)>tol)?d:((d>0)?tol:-tol));double fu=computeObjectiveValue(f,u);if(goalType==GoalType.MAXIMIZE){fu=-fu;}}"
154	"public void test(){for(int i=0;i<p.length;++i){ final double difference=Math.abs(p[i]-c[i]); final double size=Math.max(Math.abs(p[i]),Math.abs(c[i]));if((difference>(size*relativeThreshold))&&(difference>absoluteThreshold)){return false;}}}"
155	"public void test(){try{ final UnivariateRealFunction derivative=((DifferentiableUnivariateRealFunction)f).derivative();clearResult();verifySequence(min,startValue,max);double x0=startValue;double x1;int i=0;while(i<maximalIterationCount){x1=x0-(f.value(x0)/derivative.value(x0));if(Math.abs(x1-x0)<=absoluteAccuracy){setResult(x1,i);return x1;}x0=x1;++i;}throw new MaxIterationsExceededException(maximalIterationCount);}catch (ClassCastException cce) {  throw MathRuntimeException.createIllegalArgumentException(""function is not differentiable"");}}"
156	"public void test(){while(i<maximalIterationCount){x1=x0-(f.value(x0)/derivative.value(x0));if(Math.abs(x1-x0)<=absoluteAccuracy){setResult(x1,i);return x1;}x0=x1;++i;}}"
157	"public void test(){if(Math.abs(x1-x0)<=absoluteAccuracy){setResult(x1,i);return x1;}}"
158	"public void test(){if(y1==0.0){return min;}}"
159	"public void test(){if(y2==0.0){return max;}}"
160	"public void test(){if(Math.abs(y3)<=functionValueAccuracy){setResult(x3,i);return result;}}"
161	"public void test(){ final double correction=(MathUtils.sign(y2)*MathUtils.sign(y3))*(x3-x1)/Math.sqrt(delta); final double x=x3-correction; final double y=f.value(x); final double tolerance=Math.max(relativeAccuracy*Math.abs(x),absoluteAccuracy);if(Math.abs(x-oldx)<=tolerance){setResult(x,i);return result;}if(Math.abs(y)<=functionValueAccuracy){setResult(x,i);return result;}if(correction>0.0){if(MathUtils.sign(y1)+MathUtils.sign(y)==0.0){x2=x;y2=y;}else {x1=x;x2=x3;y1=y;y2=y3;}}else {if(MathUtils.sign(y2)+MathUtils.sign(y)==0.0){x1=x;y1=y;}else {x1=x3;x2=x;y1=y3;y2=y;}}}"
162	"public void test(){if(Math.abs(x-oldx)<=tolerance){setResult(x,i);return result;}}"
163	"public void test(){if(Math.abs(y)<=functionValueAccuracy){setResult(x,i);return result;}}"
164	"public void test(){if(MathUtils.sign(y1)+MathUtils.sign(y)==0.0){x2=x;y2=y;}else {x1=x;x2=x3;y1=y;y2=y3;}}"
165	"public void test(){if(MathUtils.sign(y2)+MathUtils.sign(y)==0.0){x1=x;y1=y;}else {x1=x3;x2=x;y1=y3;y2=y;}}"
166	"public void test(){if(Math.abs(max-min)<=absoluteAccuracy){m=UnivariateRealSolverUtils.midpoint(min,max);setResult(m,i);return m;}}"
167	"public void test(){if(y0*y1>=0){throw MathRuntimeException.createIllegalArgumentException(""function values at endpoints do not have different signs, ""+""endpoints: [{0}, {1}], values: [{2}, {3}]"",min,max,y0,y1);}}"
168	"public void test(){if(Math.abs(y2)<Math.abs(y1)){x0=x1;x1=x2;x2=x0;y0=y1;y1=y2;y2=y0;}}"
169	"public void test(){if(Math.abs(y1)<=functionValueAccuracy){setResult(x1,i);return result;}}"
170	"public void test(){if(Math.abs(oldDelta)<Math.max(relativeAccuracy*Math.abs(x1),absoluteAccuracy)){setResult(x1,i);return result;}}"
171	"public void test(){if(Math.abs(y2)<Math.abs(y1)){x0=x1;x1=x2;x2=x0;y0=y1;y1=y2;y2=y0;}if(Math.abs(y1)<=functionValueAccuracy){setResult(x1,i);return result;}if(Math.abs(oldDelta)<Math.max(relativeAccuracy*Math.abs(x1),absoluteAccuracy)){setResult(x1,i);return result;}double delta;if(Math.abs(y1)>Math.abs(y0)){delta=0.5*oldDelta;}else {delta=(x0-x1)/(1-y0/y1);if(delta/oldDelta>1){delta=0.5*oldDelta;}}x0=x1;y0=y1;x1=x1+delta;y1=f.value(x1);if((y1>0)==(y2>0)){x2=x0;y2=y0;}}"
172	"public void test(){if(Math.abs(y1)>Math.abs(y0)){delta=0.5*oldDelta;}else {delta=(x0-x1)/(1-y0/y1);if(delta/oldDelta>1){delta=0.5*oldDelta;}}}"
173	"public void test(){if(delta/oldDelta>1){delta=0.5*oldDelta;}}"
174	"public void test(){if(Math.abs(y2)<Math.abs(y1)){x0=x1;x1=x2;x2=x0;y0=y1;y1=y2;y2=y0;}if(Math.abs(y1)<=functionValueAccuracy){setResult(x1,i);return result;}if(Math.abs(oldDelta)<Math.max(relativeAccuracy*Math.abs(x1),absoluteAccuracy)){setResult(x1,i);return result;}double delta;if(Math.abs(y1)>Math.abs(y0)){delta=0.5*oldDelta;}else {delta=(x0-x1)/(1-y0/y1);if(delta/oldDelta>1){delta=0.5*oldDelta;}}x0=x1;y0=y1;x1=x1+delta;y1=f.value(x1);if((y1>0)==(y2>0)){x2=x0;y2=y0;}oldDelta=x2-x1;}"
175	"public void test(){if(Math.abs(y2)<Math.abs(y1)){x0=x1;x1=x2;x2=x0;y0=y1;y1=y2;y2=y0;}if(Math.abs(y1)<=functionValueAccuracy){setResult(x1,i);return result;}if(Math.abs(oldDelta)<Math.max(relativeAccuracy*Math.abs(x1),absoluteAccuracy)){setResult(x1,i);return result;}double delta;if(Math.abs(y1)>Math.abs(y0)){delta=0.5*oldDelta;}else {delta=(x0-x1)/(1-y0/y1);if(delta/oldDelta>1){delta=0.5*oldDelta;}}x0=x1;y0=y1;x1=x1+delta;y1=f.value(x1);if((y1>0)==(y2>0)){x2=x0;y2=y0;}oldDelta=x2-x1;i++;}"
176	"public void test(){if((y1>0)==(y2>0)){x2=x0;y2=y0;}}"
177	"public void test(){if(y0==0.0){return min;}}"
178	"public void test(){if(Math.abs(x-oldx)<=tolerance){setResult(x,i);return result;}if(Math.abs(y)<=functionValueAccuracy){setResult(x,i);return result;}boolean bisect=(x<x1&&(x1-x0)>0.95*(x2-x0))||(x>x1&&(x2-x1)>0.95*(x2-x0));if(!bisect){x0=x<x1?x0:x1;y0=x<x1?y0:y1;x2=x>x1?x2:x1;y2=x>x1?y2:y1;x1=x;y1=y;oldx=x;}else {double xm=0.5*(x0+x2);double ym=f.value(xm);if(MathUtils.sign(y0)+MathUtils.sign(ym)==0.0){x2=xm;y2=ym;}else {x0=xm;y0=ym;}x1=0.5*(x0+x2);y1=f.value(x1);oldx=Double.POSITIVE_INFINITY;}}"
179	"public void test(){if(!bisect){x0=x<x1?x0:x1;y0=x<x1?y0:y1;x2=x>x1?x2:x1;y2=x>x1?y2:y1;x1=x;y1=y;oldx=x;}else {double xm=0.5*(x0+x2);double ym=f.value(xm);if(MathUtils.sign(y0)+MathUtils.sign(ym)==0.0){x2=xm;y2=ym;}else {x0=xm;y0=ym;}x1=0.5*(x0+x2);y1=f.value(x1);oldx=Double.POSITIVE_INFINITY;}}"
180	"public void test(){if(MathUtils.sign(y0)+MathUtils.sign(ym)==0.0){x2=xm;y2=ym;}else {x0=xm;y0=ym;}}"
181	"public void test(){if(y1==0.0){return max;}}"
182	"public void test(){ final double q=(x2-x1)/(x1-x0); final double a=q*(y2-(1+q)*y1+q*y0); final double b=(2*q+1)*y2-(1+q)*(1+q)+q*q; final double c=(1+q)*y2; final double delta=b*b-4*a;double x; final double denominator;if(delta>=0.0){double dplus=b+Math.sqrt(delta);double dminus=b-Math.sqrt(delta);denominator=Math.abs(dplus)>Math.abs(dminus)?dplus:dminus;}else {denominator=Math.sqrt(b*b-delta);}if(denominator!=0){x=x2-2.0*c/denominator;while(x==x1||x==x2){x+=absoluteAccuracy;}}else {x=min+Math.random()*(max-min);oldx=Double.POSITIVE_INFINITY;} final double y=f.value(x); final double tolerance=Math.max(relativeAccuracy*Math.abs(x),absoluteAccuracy);if(Math.abs(x-oldx)<=tolerance){setResult(x,i);return result;}if(Math.abs(y)<=functionValueAccuracy){setResult(x,i);return result;}}"
183	"public void test(){if(delta>=0.0){double dplus=b+Math.sqrt(delta);double dminus=b-Math.sqrt(delta);denominator=Math.abs(dplus)>Math.abs(dminus)?dplus:dminus;}else {denominator=Math.sqrt(b*b-delta);}}"
184	"public void test(){if(denominator!=0){x=x2-2.0*c/denominator;while(x==x1||x==x2){x+=absoluteAccuracy;}}else {x=min+Math.random()*(max-min);oldx=Double.POSITIVE_INFINITY;}}"
185	"public void test(){double x; final double denominator;if(delta>=0.0){double dplus=b+Math.sqrt(delta);double dminus=b-Math.sqrt(delta);denominator=Math.abs(dplus)>Math.abs(dminus)?dplus:dminus;}else {denominator=Math.sqrt(b*b-delta);}if(denominator!=0){x=x2-2.0*c/denominator;while(x==x1||x==x2){x+=absoluteAccuracy;}}else {x=min+Math.random()*(max-min);oldx=Double.POSITIVE_INFINITY;} final double y=f.value(x); final double tolerance=Math.max(relativeAccuracy*Math.abs(x),absoluteAccuracy);if(Math.abs(x-oldx)<=tolerance){setResult(x,i);return result;}if(Math.abs(y)<=functionValueAccuracy){setResult(x,i);return result;}x0=x1;y0=y1;x1=x2;}"
186	"public void test(){if(delta>=0.0){double dplus=b+Math.sqrt(delta);double dminus=b-Math.sqrt(delta);denominator=Math.abs(dplus)>Math.abs(dminus)?dplus:dminus;}else {denominator=Math.sqrt(b*b-delta);}if(denominator!=0){x=x2-2.0*c/denominator;while(x==x1||x==x2){x+=absoluteAccuracy;}}else {x=min+Math.random()*(max-min);oldx=Double.POSITIVE_INFINITY;} final double y=f.value(x); final double tolerance=Math.max(relativeAccuracy*Math.abs(x),absoluteAccuracy);if(Math.abs(x-oldx)<=tolerance){setResult(x,i);return result;}if(Math.abs(y)<=functionValueAccuracy){setResult(x,i);return result;}x0=x1;y0=y1;x1=x2;y1=y2;x2=x;y2=y;oldx=x;}"
187	"public void test(){setup(f);return LazyHolder.FACTORY.newDefaultSolver().solve(f,x0,x1);}"
188	"public void test(){setup(f);UnivariateRealSolver solver=LazyHolder.FACTORY.newDefaultSolver();solver.setAbsoluteAccuracy(absoluteAccuracy);return solver.solve(f,x0,x1);}"
189	"public void test(){if(Math.abs(yInitial)<=functionValueAccuracy){setResult(initial,0);return result;}}"
190	"public void test(){if(Math.abs(yMin)<=functionValueAccuracy){setResult(min,0);return result;}}"
191	"public void test(){if(Math.abs(yMax)<=functionValueAccuracy){setResult(max,0);return result;}}"
192	"public void test(){if(Math.abs(yMin)<=functionValueAccuracy){setResult(min,0);ret=min;}else if(Math.abs(yMax)<=functionValueAccuracy){setResult(max,0);ret=max;}else {throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);}}"
193	"public void test(){if(Math.abs(yMax)<=functionValueAccuracy){setResult(max,0);ret=max;}else {throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE,min,max,yMin,yMax);}}"
194	"public void test(){if(Math.abs(dx)<=tolerance){setResult(x1,i);return result;}}"
195	"public void test(){if((Math.abs(oldDelta)<tolerance)||(Math.abs(y0)<=Math.abs(y1))){delta=0.5*dx;oldDelta=delta;}else {double r3=y1/y0;double p;double p1;if(x0==x2){p=dx*r3;p1=1.0-r3;}else {double r1=y0/y2;double r2=y1/y2;p=r3*(dx*r1-(x1-x0)*(r2-1.0));p1=(r1-1.0)*(r2-1.0);}if(p>0.0){p1=-p1;}else {p=-p;}if(2.0*p>=1.5*dx-Math.abs(tolerance*p1)||p>=Math.abs(0.5*oldDelta)){delta=0.5*dx;oldDelta=delta;}else {oldDelta=delta;delta=p/p1;}}}"
196	"public void test(){if(x0==x2){p=dx*r3;p1=1.0-r3;}else {double r1=y0/y2;double r2=y1/y2;p=r3*(dx*r1-(x1-x0)*(r2-1.0));p1=(r1-1.0)*(r2-1.0);}}"
197	"public void test(){if(p>0.0){p1=-p1;}else {p=-p;}}"
198	"public void test(){if(2.0*p>=1.5*dx-Math.abs(tolerance*p1)||p>=Math.abs(0.5*oldDelta)){delta=0.5*dx;oldDelta=delta;}else {oldDelta=delta;delta=p/p1;}}"
199	"public void test(){if((Math.abs(oldDelta)<tolerance)||(Math.abs(y0)<=Math.abs(y1))){delta=0.5*dx;oldDelta=delta;}else {double r3=y1/y0;double p;double p1;if(x0==x2){p=dx*r3;p1=1.0-r3;}else {double r1=y0/y2;double r2=y1/y2;p=r3*(dx*r1-(x1-x0)*(r2-1.0));p1=(r1-1.0)*(r2-1.0);}if(p>0.0){p1=-p1;}else {p=-p;}if(2.0*p>=1.5*dx-Math.abs(tolerance*p1)||p>=Math.abs(0.5*oldDelta)){delta=0.5*dx;oldDelta=delta;}else {oldDelta=delta;delta=p/p1;}}x0=x1;y0=y1;}"
200	"public void test(){if(Math.abs(delta)>tolerance){x1=x1+delta;}else if(dx>0.0){x1=x1+0.5*tolerance;}else if(dx<=0.0){x1=x1-0.5*tolerance;}}"
201	"public void test(){if(dx>0.0){x1=x1+0.5*tolerance;}else if(dx<=0.0){x1=x1-0.5*tolerance;}}"
202	"public void test(){if(dx<=0.0){x1=x1-0.5*tolerance;}}"
203	"public void test(){if((y1>0)==(y2>0)){x2=x0;y2=y0;delta=x1-x0;oldDelta=delta;}}"
204	"public void test(){double tolerance=Math.max(relativeAccuracy*z.abs(),absoluteAccuracy);return (isSequence(min,z.getReal(),max))&&(Math.abs(z.getImaginary())<=tolerance||z.abs()<=functionValueAccuracy);}"
205	"public void test(){{pv=coefficients[n];dv=Complex.ZERO;d2v=Complex.ZERO;for(int j=n-1;j>=0;j--){d2v=dv.add(z.multiply(d2v));dv=pv.add(z.multiply(dv));pv=coefficients[j].add(z.multiply(pv));}d2v=d2v.multiply(new Complex(2.0,0.0));double tolerance=Math.max(relativeAccuracy*z.abs(),absoluteAccuracy);if((z.subtract(oldz)).abs()<=tolerance){resultComputed=true;iterationCount=i;return z;}if(pv.abs()<=functionValueAccuracy){resultComputed=true;iterationCount=i;return z;}G=dv.divide(pv);G2=G.multiply(G);H=G2.subtract(d2v.divide(pv));delta=N1.multiply((N.multiply(H)).subtract(G2));Complex deltaSqrt=delta.sqrt();Complex dplus=G.add(deltaSqrt);Complex dminus=G.subtract(deltaSqrt);denominator=dplus.abs()>dminus.abs()?dplus:dminus;if(denominator.equals(new Complex(0.0,0.0))){z=z.add(new Complex(absoluteAccuracy,absoluteAccuracy));oldz=new Complex(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);}else {oldz=z;z=z.subtract(N.divide(denominator));}i++;}}"
206	"public void test(){if((z.subtract(oldz)).abs()<=tolerance){resultComputed=true;iterationCount=i;return z;}}"
207	"public void test(){if(pv.abs()<=functionValueAccuracy){resultComputed=true;iterationCount=i;return z;}}"
208	"public void test(){for(int j=n-1;j>=0;j--){d2v=dv.add(z.multiply(d2v));dv=pv.add(z.multiply(dv));pv=coefficients[j].add(z.multiply(pv));}d2v=d2v.multiply(new Complex(2.0,0.0));double tolerance=Math.max(relativeAccuracy*z.abs(),absoluteAccuracy);if((z.subtract(oldz)).abs()<=tolerance){resultComputed=true;iterationCount=i;return z;}if(pv.abs()<=functionValueAccuracy){resultComputed=true;iterationCount=i;return z;}G=dv.divide(pv);G2=G.multiply(G);H=G2.subtract(d2v.divide(pv));delta=N1.multiply((N.multiply(H)).subtract(G2));Complex deltaSqrt=delta.sqrt();Complex dplus=G.add(deltaSqrt);Complex dminus=G.subtract(deltaSqrt);denominator=dplus.abs()>dminus.abs()?dplus:dminus;if(denominator.equals(new Complex(0.0,0.0))){z=z.add(new Complex(absoluteAccuracy,absoluteAccuracy));oldz=new Complex(Double.POSITIVE_INFINITY,Double.POSITIVE_INFINITY);}else {oldz=z;z=z.subtract(N.divide(denominator));}i++;}"
209	"public void test(){if(coefficients[i]!=0){if(s.length()>0){if(coefficients[i]<0){s.append("" - "");}else {s.append("" + "");}}else {if(coefficients[i]<0){s.append(""-"");}}double absAi=Math.abs(coefficients[i]);if((absAi-1)!=0){s.append(Double.toString(absAi));s.append(' ');}s.append(""x"");if(i>1){s.append('^');s.append(Integer.toString(i));}}}"
210	"public void test(){for(int i=0;i<n;i++){c[i]=y[i];d[i]=y[i]; final double dist=Math.abs(z-x[i]);if(dist<min_dist){nearest=i;min_dist=dist;}}}"
211	"public void test(){if(i>=minimalIterationCount){ final double delta=Math.abs(s-olds); final double rLimit=relativeAccuracy*(Math.abs(olds)+Math.abs(s));if((delta<=rLimit)||(delta<=absoluteAccuracy)){setResult(s,i);return result;}}}"
212	"public void test(){if((delta<=rLimit)||(delta<=absoluteAccuracy)){setResult(s,i);return result;}}"
213	"public void test(){for(int i=0;i<maximalIterationCount;++i){ final double t=stage(f,min,max,n); final double delta=Math.abs(t-oldt); final double limit=Math.max(absoluteAccuracy,relativeAccuracy*(Math.abs(oldt)+Math.abs(t)));if((i+1>=minimalIterationCount)&&(delta<=limit)){setResult(t,i);return result;}double ratio=Math.min(4,Math.pow(delta/limit,0.5/abscissas.length));n=Math.max((int)(ratio*n),n+1);oldt=t;}}"
214	"public void test(){if((i+1>=minimalIterationCount)&&(delta<=limit)){setResult(t,i);return result;}}"
215	"public void test(){if(i>=minimalIterationCount){ final double delta=Math.abs(t-oldt); final double rLimit=relativeAccuracy*(Math.abs(oldt)+Math.abs(t));if((delta<=rLimit)||(delta<=absoluteAccuracy)){setResult(t,i);return result;}}}"
216	"public void test(){if((delta<=rLimit)||(delta<=absoluteAccuracy)){setResult(t,i);return result;}}"
217	"public void test(){if(x<0||x>1){throw MathRuntimeException.createIllegalArgumentException(""{0} out of [{1}, {2}] range"",x,0,1);}if(y<0||y>1){throw MathRuntimeException.createIllegalArgumentException(""{0} out of [{1}, {2}] range"",y,0,1);} final double x2=x*x; final double x3=x2*x; final double y2=y*y; final double y3=y2*y;return a00+a01*y+a02*y2+a03*y3+a10*x+a11*x+a12*x+a13*x+a20*x2+a21*x2+a22*x2+a23*x2+a30*x3+a31*x3+a32*x3+a33*x3;}"
218	"public void test(){if(Math.abs(diffNorm)<Math.ulp(1.0)){return sd.getValue();}}"
219	"public void test(){if(xval[i]-xval[ileft]>xval[iright]-xval[i]){edge=ileft;}else {edge=iright;}double sumWeights=0;double sumX=0;double sumXSquared=0;double sumY=0;double sumXY=0;double denom=Math.abs(1.0/(xval[edge]-x));for(int k=ileft;k<=iright;++k){ final double xk=xval[k]; final double yk=yval[k]; final double dist=(k<i)?x-xk:xk-x; final double w=tricube(dist*denom)*robustnessWeights[k]; final double xkw=xk*w;sumWeights+=w;sumX+=xkw;sumXSquared+=xk*xkw;sumY+=yk*w;sumXY+=yk*xkw;} final double meanX=sumX/sumWeights; final double meanY=sumY/sumWeights; final double meanXY=sumXY/sumWeights; final double meanXSquared=sumXSquared/sumWeights; final double beta;}"
220	"public void test(){if(Math.sqrt(Math.abs(meanXSquared-meanX*meanX))<accuracy){beta=0;}else {beta=(meanXY-meanX*meanY)/(meanXSquared-meanX*meanX);}}"
221	"public void test(){double sumY=0;double sumXY=0;double denom=Math.abs(1.0/(xval[edge]-x));for(int k=ileft;k<=iright;++k){ final double xk=xval[k]; final double yk=yval[k]; final double dist=(k<i)?x-xk:xk-x; final double w=tricube(dist*denom)*robustnessWeights[k]; final double xkw=xk*w;sumWeights+=w;sumX+=xkw;sumXSquared+=xk*xkw;sumY+=yk*w;sumXY+=yk*xkw;} final double meanX=sumX/sumWeights; final double meanY=sumY/sumWeights; final double meanXY=sumXY/sumWeights; final double meanXSquared=sumXSquared/sumWeights; final double beta;if(Math.sqrt(Math.abs(meanXSquared-meanX*meanX))<accuracy){beta=0;}else {beta=(meanXY-meanX*meanY)/(meanXSquared-meanX*meanX);} final double alpha=meanY-beta*meanX;res[i]=beta*x+alpha;residuals[i]=Math.abs(yval[i]-res[i]);}"
222	"public void test(){if(Math.abs(medianResidual)<accuracy){break;}}"
223	"public void test(){if(!entries.containsKey(key)){double delta=Math.abs(iter.value());max+=Math.abs(delta);}}"
224	"public void test(){while(iter.hasNext()){iter.advance();double delta=Math.abs(iter.value()-v.getEntry(iter.key()));if(delta>max){max=delta;}}}"
225	"public void test(){if(delta>max){max=delta;}}"
226	"public void test(){for(int i=0;i<v.length;i++){double delta=Math.abs(getEntry(i)-v[i]);if(delta>max){max=delta;}}}"
227	"public void test(){for(int j=i+1;j<order;++j){ final double[] lJ=lTData[j]; final double lIJ=lI[j]; final double lJI=lJ[i]; final double maxDelta=relativeSymmetryThreshold*Math.max(Math.abs(lIJ),Math.abs(lJI));if(Math.abs(lIJ-lJI)>maxDelta){throw new NotSymmetricMatrixException();}lJ[i]=0;}}"
228	"public void test(){if(Math.abs(lIJ-lJI)>maxDelta){throw new NotSymmetricMatrixException();}}"
229	"public void test(){if(Math.abs(sum)>largest){largest=Math.abs(sum);max=row;}}"
230	"public void test(){if(Math.abs(lu[max][col])<singularityThreshold){singular=true;return ;}}"
231	"public void test(){if(sum.abs().compareTo(largest)==1){largest=sum.abs();max=row;}}"
232	"public void test(){if(lu[max][col].abs().compareTo(TOO_SMALL)<=0){lu=null;throw new SingularMatrixException();}}"
233	"public void test(){if(Math.abs(mij-mji)>(Math.max(Math.abs(mij),Math.abs(mji))*eps)){return false;}}"
234	"public void test(){if(Math.abs(realEigenvalues[i])>maxAbsoluteValue){maxAbsoluteValue=Math.abs(realEigenvalues[i]);}}"
235	"public void test(){if(Math.abs(e[i])>maxAbsoluteValue){maxAbsoluteValue=Math.abs(e[i]);}}"
236	"public void test(){if(Math.abs(realEigenvalues[i])<=MathUtils.EPSILON*maxAbsoluteValue){realEigenvalues[i]=0.0;}}"
237	"public void test(){if(Math.abs(e[i])<=MathUtils.EPSILON*maxAbsoluteValue){e[i]=0.0;}}"
238	"public void test(){for(m=j;m<n-1;m++){double delta=Math.abs(realEigenvalues[m])+Math.abs(realEigenvalues[m+1]);if(Math.abs(e[m])+delta==delta){break;}}}"
239	"public void test(){if(Math.abs(e[m])+delta==delta){break;}}"
240	"public void test(){for(i=m-1;i>=j;i--){double p=s*e[i];double h=c*e[i];if(Math.abs(p)>=Math.abs(q)){c=q/p;t=Math.sqrt(c*c+1.0);e[i+1]=p*t;s=1.0/t;c=c*s;}else {s=p/q;t=Math.sqrt(s*s+1.0);e[i+1]=q*t;c=1.0/t;s=s*c;}if(e[i+1]==0.0){realEigenvalues[i+1]-=u;e[m]=0.0;break;}q=realEigenvalues[i+1]-u;t=(realEigenvalues[i]-q)*s+2.0*c;u=s*t;realEigenvalues[i+1]=q+u;q=c*t-h;for(int ia=0;ia<n;ia++){p=z[ia][i+1];z[ia][i+1]=s*z[ia][i]+c*p;z[ia][i]=c*z[ia][i]-s*p;}}}"
241	"public void test(){if(Math.abs(p)>=Math.abs(q)){c=q/p;t=Math.sqrt(c*c+1.0);e[i+1]=p*t;s=1.0/t;c=c*s;}else {s=p/q;t=Math.sqrt(s*s+1.0);e[i+1]=q*t;c=1.0/t;s=s*c;}}"
242	"public void test(){for(int i=0;i<n;i++){int k=i;double p=realEigenvalues[i];for(int j=i+1;j<n;j++){if(realEigenvalues[j]>p){k=j;p=realEigenvalues[j];}}if(k!=i){realEigenvalues[k]=realEigenvalues[i];realEigenvalues[i]=p;for(int j=0;j<n;j++){p=z[j][i];z[j][i]=z[j][k];z[j][k]=p;}}}}"
243	"public void test(){if(realEigenvalues[j]>p){k=j;p=realEigenvalues[j];}}"
244	"public void test(){if(k!=i){realEigenvalues[k]=realEigenvalues[i];realEigenvalues[i]=p;for(int j=0;j<n;j++){p=z[j][i];z[j][i]=z[j][k];z[j][k]=p;}}}"
245	"public void test(){if(Math.abs(realEigenvalues[i])<MathUtils.EPSILON*maxAbsoluteValue){realEigenvalues[i]=0.0;}}"
246	"public void test(){double t=Math.abs(t(m,mu,v,n));distribution.setDegreesOfFreedom(n-1);return 2.0*distribution.cumulativeProbability(-t);}"
247	"public void test(){double t=Math.abs(t(m1,m2,v1,v2,n1,n2));double degreesOfFreedom=0;degreesOfFreedom=df(v1,v2,n1,n2);distribution.setDegreesOfFreedom(degreesOfFreedom);return 2.0*distribution.cumulativeProbability(-t);}"
248	"public void test(){double t=Math.abs(homoscedasticT(m1,m2,v1,v2,n1,n2));double degreesOfFreedom=n1+n2-2;distribution.setDegreesOfFreedom(degreesOfFreedom);return 2.0*distribution.cumulativeProbability(-t);}"
249	"public void test(){if(Math.abs(sumExpected-sumObserved)>1.0E-5){ratio=sumObserved/sumExpected;rescale=true;}}"
250	"public void test(){if(i==j){out[i][j]=0.0;}else {double r=correlationMatrix.getEntry(i,j);double t=Math.abs(r*Math.sqrt((nObs-2)/(1-r*r)));out[i][j]=2*(1-tDistribution.cumulativeProbability(t));}}"
251	"public void test(){if(n==0){xbar=x;ybar=y;}else {double dx=x-xbar;double dy=y-ybar;sumXX+=dx*dx/(n+1.0);sumYY+=dy*dy/(n+1.0);sumXY+=dx*dy/(n+1.0);xbar+=dx/(n+1.0);ybar+=dy/(n+1.0);}}"
252	"public void test(){if(n>0){double dx=x-xbar;double dy=y-ybar;sumXX-=dx*dx/(n-1.0);sumYY-=dy*dy/(n-1.0);sumXY-=dx*dy/(n-1.0);xbar-=dx/(n-1.0);ybar-=dy/(n-1.0);sumX-=x;sumY-=y;n--;if(n>2){distribution.setDegreesOfFreedom(n-2);}}}"
253	"public void test(){if(Math.abs(sumXX)<10*Double.MIN_VALUE){return Double.NaN;}}"
254	"public void test(){test(values,0,0);return evaluate(values,0,values.length,p);}"
255	"public void test(){if((p>100)||(p<=0)){throw MathRuntimeException.createIllegalArgumentException(""out of bounds quantile value: {0}, must be in (0, 100]"",p);}}"
256	"public void test(){test(values,begin,length);if((p>100)||(p<=0)){throw MathRuntimeException.createIllegalArgumentException(""out of bounds quantile value: {0}, must be in (0, 100]"",p);}if(length==0){return Double.NaN;}if(length==1){return values[begin];}double n=length;double pos=p*(n+1)/100;double fpos=Math.floor(pos);int intPos=(int)fpos;double dif=pos-fpos;double[] sorted=new double[length];System.arraycopy(values,begin,sorted,0,length);Arrays.sort(sorted);if(pos<1){return sorted[0];}if(pos>=n){return sorted[length-1];}double lower=sorted[intPos-1];double upper=sorted[intPos];return lower+dif*(upper-lower);}"
257	"public void test(){if(p<=0||p>100){throw MathRuntimeException.createIllegalArgumentException(""out of bounds quantile value: {0}, must be in (0, 100]"",p);}}"
258	"public void test(){if(p<=0||p>100){throw MathRuntimeException.createIllegalArgumentException(""out of bounds quantile value: {0}, must be in (0, 100]"",p);}quantile=p;}"
259	"public void test(){if(percentileImpl instanceof Percentile){((Percentile)percentileImpl).setQuantile(p);}else {try{percentileImpl.getClass().getMethod(SET_QUANTILE_METHOD_NAME,new Class[]{Double.TYPE}).invoke(percentileImpl,new Object[]{Double.valueOf(p)});}catch (NoSuchMethodException e1) {  throw MathRuntimeException.createIllegalArgumentException(UNSUPPORTED_METHOD_MESSAGE,percentileImpl.getClass().getName(),SET_QUANTILE_METHOD_NAME);}catch (IllegalAccessException e2) {  throw MathRuntimeException.createIllegalArgumentException(ILLEGAL_ACCESS_MESSAGE,SET_QUANTILE_METHOD_NAME,percentileImpl.getClass().getName());}catch (InvocationTargetException e3) {  throw MathRuntimeException.createIllegalArgumentException(e3.getCause());}}}"